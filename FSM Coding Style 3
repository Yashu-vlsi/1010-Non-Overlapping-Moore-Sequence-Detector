module fsm(
  input clk, rst, a,
  output reg y
);
  parameter s0 = 3'b000,
            s1 = 3'b001,
            s2 = 3'b010,
            s3 = 3'b011,
            s4 = 3'b100;

  reg [2:0] state, next_state;

   //Sequential block: state register
  always @(posedge clk or posedge rst) begin
    if (rst)
      state <= s0;
    else
      state <= next_state;
  end

  //Combinational block: next state logic
  always @(*) begin
    case (state)
      s0: next_state = a ? s1 : s0;
      s1: next_state = a ? s1 : s2;
      s2: next_state = a ? s3 : s0;
      s3: next_state = a ? s4 : s1;
      s4: next_state = a ? s1 : s0;
      default: next_state = s0;
    endcase
  end

   //Sequential block: registered output logic
  always @(posedge clk or posedge rst) begin
    if (rst)
      y <= 1'b0;
    else begin
      case (state)
        s0:y<=1'b0;
        s1:y<=1'b0;
        s2:y<=1'b0;
        s3:y<=1'b0;
        s4: y <= 1'b1;
        default: y <= 1'b0;
      endcase
    end
  end

endmodule
