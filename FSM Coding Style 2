module fsm(
  input clk, rst, a,
  output reg y
);
  parameter s0=3'b000,
            s1=3'b001,
            s2=3'b010,
            s3=3'b011,
            s4=3'b100;

  reg [2:0] state, next_state;

  // Sequential block – state register
  always @(posedge clk or posedge rst)
    if (rst)
      state <= s0;
    else
      state <= next_state;

  // Combinational block – next-state and output logic together
  always @(*) begin
    // Default assignments
    next_state = s0;
    y = 1'b0;

    case (state)
      s0: begin
        next_state = a ? s1 : s0;
        y = 1'b0;
      end

      s1: begin
        next_state = a ? s1 : s2;
        y = 1'b0;
      end

      s2: begin
        next_state = a ? s3 : s0;
        y = 1'b0;
      end

      s3: begin
        next_state = a ? s4 : s1;
        y = 1'b0;
      end

      s4: begin
        next_state = a ? s1 : s0;
        y = 1'b1; // Output high for detected "1010"
      end

      default: begin
        next_state = s0;
        y = 1'b0;
      end
    endcase
  end
endmodule
